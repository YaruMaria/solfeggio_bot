import asyncio
import logging
import sqlite3
import random
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InputFile
import os
from pathlib import Path
from config import BOT_TOKEN

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
dp = Dispatcher()
bot = Bot(token=BOT_TOKEN)

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
conn = sqlite3.connect('user.db')
cursor = conn.cursor()

# –ü–æ–ª—É—á–∞–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ —Å –±–æ—Ç–æ–º
BASE_DIR = Path(__file__).parent
MEDIA_DIR = BASE_DIR / "media"

if not MEDIA_DIR.exists():
    MEDIA_DIR.mkdir()
    logging.info(f"–°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ –¥–ª—è –º–µ–¥–∏–∞: {MEDIA_DIR}")

# –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü
cursor.execute('''
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    username TEXT,
    first_name TEXT,
    last_name TEXT
);
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS music_progress (
    user_id INTEGER,
    test_type TEXT,
    score INTEGER,
    last_attempt TEXT,
    PRIMARY KEY (user_id, test_type)
);
''')

CLEFS_DATA = {
    "treble": {
        "name": "–°–∫—Ä–∏–ø–∏—á–Ω—ã–π –∫–ª—é—á",
        "description": "–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤—ã—Å–æ–∫–∏—Ö –Ω–æ—Ç",
        "image_path": str(MEDIA_DIR / "treble_clef.png")
    },
    "bass": {
        "name": "–ë–∞—Å–æ–≤—ã–π –∫–ª—é—á",
        "description": "–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –Ω–∏–∑–∫–∏—Ö –Ω–æ—Ç",
        "image_path": str(MEDIA_DIR / "bass_clef.png")
    }
}

conn.commit()

# –•—Ä–∞–Ω–∏–ª–∏—â–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π
user_states = {}


# –û—Å–Ω–æ–≤–Ω—ã–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="1 –∫–ª–∞—Å—Å"), KeyboardButton(text="2 –∫–ª–∞—Å—Å")],
            [KeyboardButton(text="3 –∫–ª–∞—Å—Å"), KeyboardButton(text="4 –∫–ª–∞—Å—Å")],
            [KeyboardButton(text="5 –∫–ª–∞—Å—Å"), KeyboardButton(text="6 –∫–ª–∞—Å—Å")],
            [KeyboardButton(text="7 –∫–ª–∞—Å—Å")],
            [KeyboardButton(text="–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ")],
            [KeyboardButton(text="–ú–æ–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è"), KeyboardButton(text="–ú–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å")]
        ],
        resize_keyboard=True
    )


def get_class_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
            [KeyboardButton(text="–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è")],
            [KeyboardButton(text="–£—á–µ–±–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã")],
            [KeyboardButton(text="–ù–æ—Ç—ã")],
            [KeyboardButton(text="–ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )


def get_music_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="–ö–ª—é—á–∏")],
            [KeyboardButton(text="–ù–æ—Ç—ã –≤ —Å–∫—Ä–∏–ø–∏—á–Ω–æ–º –∫–ª—é—á–µ")],
            [KeyboardButton(text="–ù–æ—Ç—ã –≤ –±–∞—Å–æ–≤–æ–º –∫–ª—é—á–µ")],
            [KeyboardButton(text="–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞")],
            [KeyboardButton(text="–û–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ –Ω–æ—Ç")],
            [KeyboardButton(text="–ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )


def get_clef_quiz_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="–°–∫—Ä–∏–ø–∏—á–Ω—ã–π"), KeyboardButton(text="–ë–∞—Å–æ–≤—ã–π")],
            [KeyboardButton(text="–ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )


# –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@dp.message(Command('start'))
async def start(message: types.Message):
    user_id = message.from_user.id
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    if not cursor.fetchone():
        cursor.execute(
            'INSERT INTO users (user_id, username, first_name, last_name) VALUES (?, ?, ?, ?)',
            (user_id, message.from_user.username, message.from_user.first_name, message.from_user.last_name)
        )
        conn.commit()

    await message.answer(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –±–æ—Ç! –í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å:",
        reply_markup=get_main_keyboard()
    )


@dp.message(Command('help'))
async def help_command(message: types.Message):
    await message.answer(
        "–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–≥–∞–µ—Ç –∏–∑—É—á–∞—Ç—å –º—É–∑—ã–∫–∞–ª—å–Ω—É—é —Ç–µ–æ—Ä–∏—é.\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start - –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
        "/help - –ø–æ–º–æ—â—å\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è.",
        reply_markup=get_main_keyboard()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∞—Å—Å–æ–≤
@dp.message(F.text.endswith("–∫–ª–∞—Å—Å"))
async def class_handler(message: types.Message):
    class_num = message.text.split(" ")[0]
    user_states[message.from_user.id] = {"current_class": class_num}
    await message.answer(
        f"–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –¥–ª—è –∫–ª–∞—Å—Å–∞ {class_num}:",
        reply_markup=get_class_keyboard()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–∞
@dp.message(F.text == "–ù–æ—Ç—ã")
async def music_menu_handler(message: types.Message):
    await message.answer(
        "–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è:",
        reply_markup=get_music_keyboard()
    )


@dp.message(F.text == "–ö–ª—é—á–∏")
async def clefs_intro(message: types.Message):
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã
    user_states[message.from_user.id] = {
        "mode": "clef_quiz",
        "score": 0,
        "total": 0,
        "current_answer": None  # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ —Å—Ä–∞–∑—É
    }

    await message.answer(
        "üéµ –í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –ø–æ –º—É–∑—ã–∫–∞–ª—å–Ω—ã–º –∫–ª—é—á–∞–º!\n"
        "–û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ, –∫–∞–∫–æ–π –∫–ª—é—á –ø–æ–∫–∞–∑–∞–Ω –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏:",
        reply_markup=get_clef_quiz_keyboard()
    )
    await send_random_clef(message)


async def send_random_clef(message: types.Message):
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ —Ä–µ–∂–∏–º–µ –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã
    if user_id not in user_states or user_states[user_id].get("mode") != "clef_quiz":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –≤–∏–∫—Ç–æ—Ä–∏–Ω—É —á–µ—Ä–µ–∑ –º–µ–Ω—é")
        return

    clef_type = random.choice(list(CLEFS_DATA.keys()))
    clef = CLEFS_DATA[clef_type]

    # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
    user_states[user_id]["current_answer"] = clef_type

    try:
        with open(clef["image_path"], 'rb') as photo:
            await message.answer_photo(
                types.BufferedInputFile(photo.read(), filename="clef.png"),
                caption="–≠—Ç–æ —Å–∫—Ä–∏–ø–∏—á–Ω—ã–π –∏–ª–∏ –±–∞—Å–æ–≤—ã–π –∫–ª—é—á?",
                reply_markup=get_clef_quiz_keyboard()
            )
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
        await message.answer(
            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {clef['name']}\n"
            f"–û–ø–∏—Å–∞–Ω–∏–µ: {clef['description']}",
            reply_markup=get_clef_quiz_keyboard()
        )


@dp.message(F.text.in_(["–°–∫—Ä–∏–ø–∏—á–Ω—ã–π", "–ë–∞—Å–æ–≤—ã–π"]))
async def check_clef_answer(message: types.Message):
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user_id not in user_states or user_states[user_id].get("mode") != "clef_quiz":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –≤–∏–∫—Ç–æ—Ä–∏–Ω—É —Å–Ω–∞—á–∞–ª–∞")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞
    if "current_answer" not in user_states[user_id]:
        await message.answer("–û—à–∏–±–∫–∞: –≤–æ–ø—Ä–æ—Å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω. –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–Ω–æ–≤–æ.")
        await clefs_intro(message)
        return

    user_answer = message.text
    correct_type = user_states[user_id]["current_answer"]
    correct_name = CLEFS_DATA[correct_type]["name"]

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    user_states[user_id]["total"] += 1

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–≤–µ—Ç
    is_correct = (user_answer == "–°–∫—Ä–∏–ø–∏—á–Ω—ã–π" and correct_type == "treble") or \
                 (user_answer == "–ë–∞—Å–æ–≤—ã–π" and correct_type == "bass")

    if is_correct:
        user_states[user_id]["score"] += 1
        response = f"‚úÖ –í–µ—Ä–Ω–æ! –≠—Ç–æ {correct_name}"
    else:
        response = f"‚ùå –ù–µ–≤–µ—Ä–Ω–æ. –≠—Ç–æ {correct_name}"

    await message.answer(
        f"{response}\n{CLEFS_DATA[correct_type]['description']}",
        reply_markup=get_clef_quiz_keyboard()
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
    await asyncio.sleep(1)
    await send_random_clef(message)


@dp.message(F.text == "–ù–∞–∑–∞–¥")
@dp.message(F.text == "–ù–∞–∑–∞–¥")
async def back_from_quiz(message: types.Message):
    user_id = message.from_user.id
    if user_id in user_states and user_states[user_id].get("mode") == "clef_quiz":
        score = user_states[user_id].get("score", 0)
        total = user_states[user_id].get("total", 0)
        await message.answer(
            f"üèÅ –í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n"
            f"–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: {score} –∏–∑ {total}",
            reply_markup=get_music_keyboard()
        )
        user_states[user_id] = {}
    else:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:", reply_markup=get_class_keyboard())


# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    await dp.start_polling(bot)


if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    finally:
        conn.close()